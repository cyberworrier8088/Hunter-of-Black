<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hunter of Black: Warpath v11.0</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        /* HUD - Warpath Style */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        #hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95) 0%, transparent 100%);
        }

        .stat-box {
            text-align: center;
        }

        .label {
            font-size: 10px;
            color: #666;
            font-weight: 900;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }

        .val {
            font-size: 24px;
            color: #fff;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        #weapon-card {
            background: rgba(5, 5, 5, 0.9);
            border: 1px solid #333;
            padding: 10px 25px;
            transform: skewX(-15deg);
            border-left: 4px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        #weapon-name {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #progress-text {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
            font-weight: bold;
        }

        #prog-bar-bg {
            width: 100%;
            height: 6px;
            background: #222;
            margin-top: 6px;
        }

        #prog-bar-fill {
            width: 0%;
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.3s;
        }

        #hp-bar-bg {
            width: 300px;
            height: 10px;
            background: #111;
            border: 1px solid #444;
            transform: skewX(-15deg);
            position: relative;
            overflow: hidden;
        }

        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #ff0040;
            box-shadow: 0 0 15px #ff0040;
            transition: width 0.1s;
        }

        /* Reticle */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
        }

        .ret-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            box-shadow: 0 0 8px white;
        }

        .ret-circle {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: 0.1s;
        }

        /* Mobile Controls */
        .mobile-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .zone {
            pointer-events: auto;
            position: absolute;
        }

        #stick-base {
            bottom: 40px;
            left: 40px;
            width: 130px;
            height: 130px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05), transparent);
        }

        #stick-nub {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }

        #btn-jump {
            bottom: 70px;
            right: 150px;
            width: 70px;
            height: 70px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            display: grid;
            place-items: center;
            font-weight: bold;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
        }

        #btn-fire {
            bottom: 40px;
            right: 40px;
            width: 90px;
            height: 90px;
            border: 3px solid #ff0040;
            border-radius: 50%;
            color: #ff0040;
            display: grid;
            place-items: center;
            font-weight: 900;
            font-size: 16px;
            background: rgba(20, 0, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.2);
        }

        #btn-fire:active {
            background: #ff0040;
            color: black;
            transform: scale(0.95);
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 60px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 8px;
            margin-bottom: 5px;
            text-shadow: 0 0 30px #fff;
            text-align: center;
        }

        h2 {
            font-size: 14px;
            color: #666;
            letter-spacing: 12px;
            margin-bottom: 50px;
            text-transform: uppercase;
        }

        .btn {
            padding: 18px 60px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            font-size: 22px;
            font-weight: 900;
            cursor: pointer;
            transition: 0.2s;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 30px #fff;
        }

        #dmg-overlay {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.6));
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        /* Floating Text */
        .float-txt {
            position: absolute;
            color: #fff;
            font-weight: 900;
            font-size: 24px;
            pointer-events: none;
            animation: float 0.8s forwards;
            text-shadow: 0 0 10px #000;
        }

        @keyframes float {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }

            50% {
                transform: translate(-50%, -80px) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -120px) scale(1.0);
                opacity: 0;
            }
        }

        #difficulty-toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0040;
            font-weight: bold;
            letter-spacing: 5px;
            font-size: 20px;
            text-shadow: 0 0 10px red;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="dmg-overlay"></div>
    <div id="difficulty-toast">THREAT LEVEL INCREASED</div>

    <div id="ui-layer">
        <div id="hud-top">
            <div class="stat-box" style="text-align:left;">
                <div class="label">WEAPON SYSTEMS</div>
                <div id="weapon-card">
                    <div id="weapon-name">SHADOW PISTOL</div>
                    <div id="progress-text">NEXT: 50 KILLS</div>
                    <div id="prog-bar-bg">
                        <div id="prog-bar-fill"></div>
                    </div>
                </div>
            </div>

            <div class="stat-box">
                <div class="label">INTEGRITY</div>
                <div id="hp-bar-bg">
                    <div id="hp-bar-fill"></div>
                </div>
            </div>

            <div class="stat-box" style="text-align:right;">
                <div class="label">NEUTRALIZED</div>
                <div class="val" id="kill-disp">0</div>
            </div>
        </div>
        <div id="crosshair">
            <div class="ret-dot"></div>
            <div class="ret-circle" id="ret-ring"></div>
        </div>
    </div>

    <div class="mobile-ui" id="mobile-controls">
        <div class="zone" id="stick-base">
            <div id="stick-nub"></div>
        </div>
        <div class="zone" id="btn-jump">JUMP</div>
        <div class="zone" id="btn-fire">FIRE</div>
    </div>

    <div id="start-screen" class="screen">
        <h1>Hunter of Black</h1>
        <h2>Warpath v11.0</h2>
        <button class="btn" id="start-btn">INITIATE</button>
        <p style="color:#333; margin-top:30px; font-size:10px; font-family:monospace;">AUDIO: CUSTOM + SYNTH</p>
    </div>

    <div id="game-over" class="screen hidden">
        <h1 style="color:#ff0040">CRITICAL FAILURE</h1>
        <p style="color:#fff; margin-bottom:30px; font-size: 20px;">CONFIRMED KILLS: <span id="final-kills"
                style="color:cyan; font-weight:bold;">0</span></p>
        <button class="btn" onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- AUDIO ENGINE ---
        const SoundGen = {
            shootUrl: "https://www.myinstants.com/media/sounds/gunshotjbudden.mp3",
            dieUrl: "https://www.myinstants.com/media/sounds/dry-fart.mp3",
            ctx: null,
            init: () => {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                SoundGen.ctx = new AudioContext();
            },
            playShoot: () => {
                const a = new Audio(SoundGen.shootUrl);
                a.volume = 0.2;
                a.currentTime = 0;
                a.play().catch(e => SoundGen.playProceduralShoot());
            },
            playDeath: () => {
                const a = new Audio(SoundGen.dieUrl);
                a.volume = 1.0;
                a.play().catch(e => { });
            },
            playProceduralShoot: () => {
                if (!SoundGen.ctx) return;
                const osc = SoundGen.ctx.createOscillator();
                const gain = SoundGen.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, SoundGen.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, SoundGen.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, SoundGen.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, SoundGen.ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(SoundGen.ctx.destination);
                osc.start(); osc.stop(SoundGen.ctx.currentTime + 0.1);
            },
            playExplosion: () => {
                if (!SoundGen.ctx) return;
                const osc = SoundGen.ctx.createOscillator();
                const gain = SoundGen.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, SoundGen.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, SoundGen.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, SoundGen.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, SoundGen.ctx.currentTime + 0.3);
                osc.connect(gain); gain.connect(SoundGen.ctx.destination);
                osc.start(); osc.stop(SoundGen.ctx.currentTime + 0.3);
            },
            playHit: () => {
                if (!SoundGen.ctx) return;
                const osc = SoundGen.ctx.createOscillator();
                const gain = SoundGen.ctx.createGain();
                osc.frequency.setValueAtTime(150, SoundGen.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(0, SoundGen.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, SoundGen.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, SoundGen.ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(SoundGen.ctx.destination);
                osc.start(); osc.stop(SoundGen.ctx.currentTime + 0.1);
            }
        };

        // --- CONSTANTS ---
        const CONFIG = { speed: 22, jump: 16, gravity: 45, sens: 0.002, chunkSize: 120 };
        let GAME_PARAMS = { maxEnemies: 20, enemySpeedMult: 1.0, enemyHpMult: 1.0 };

        const WEAPONS = [
            { name: "SHADOW PISTOL", req: 0, dmg: 40, rate: 0.25, spd: 130, col: 0x00ffff, type: 'semi', scale: 1 },
            { name: "MIDNIGHT SMG", req: 50, dmg: 20, rate: 0.09, spd: 150, col: 0x00ff80, type: 'auto', scale: 1 },
            { name: "ECLIPSE SHOTGUN", req: 150, dmg: 25, rate: 0.9, spd: 110, col: 0xffaa00, type: 'spread', count: 7, scale: 1.2 },
            { name: "ABYSS RAILGUN", req: 300, dmg: 500, rate: 1.4, spd: 350, col: 0xaa00ff, type: 'rail', scale: 1.5 }
        ];

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let isPlaying = false, isMobile = false, lastTime = performance.now();
        let kills = 0, currentWepIdx = 0;

        const mapChunks = new Map();
        const enemies = [], bullets = [], particles = [], texts = [];
        const pool = { bullets: [], particles: [], enemies: [] };

        const player = {
            hp: 100, maxHp: 100,
            pos: new THREE.Vector3(0, 5, 0), vel: new THREE.Vector3(),
            handGroup: null, muzzle: null, recoil: 0, lastShot: 0,
            sway: { x: 0, y: 0 }
        };

        const input = { x: 0, y: 0, jump: false, fire: false };
        let yaw = 0, pitch = 0;

        // --- INIT ---
        function init() {
            isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            if (isMobile) document.getElementById('mobile-controls').style.display = 'block';

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024);
            scene.add(sun);

            const pLight = new THREE.PointLight(0xffffff, 0.3, 30);
            camera.add(pLight);

            createHandModel();
            updateWorld();
            setupInput();
            requestAnimationFrame(animate);
        }

        // --- VOXEL SYSTEM ---
        function createVoxelGroup(voxels, scale) {
            const g = new THREE.Group();
            const geo = new THREE.BoxGeometry(scale, scale, scale);
            voxels.forEach(v => {
                const mat = new THREE.MeshStandardMaterial({
                    color: v.c,
                    emissive: v.g ? v.c : 0,
                    emissiveIntensity: v.g ? 1 : 0
                });
                const m = new THREE.Mesh(geo, mat);
                m.position.set(v.x * scale, v.y * scale, v.z * scale);
                m.castShadow = true;
                g.add(m);
            });
            return g;
        }

        // --- WEAPON ---
        function getWeaponVoxels(type) {
            const v = [];
            const cBody = 0x222222, cGrip = 0x111111;
            const col = WEAPONS[type].col;
            v.push({ x: 2, y: -2, z: 3, c: 0x111111 }, { x: 2, y: -2, z: 4, c: 0x111111 });
            if (type === 0) {
                v.push({ x: 2, y: -1, z: 2, c: cGrip });
                v.push({ x: 2, y: 0, z: 2, c: cBody }, { x: 2, y: 0, z: 1, c: cBody }, { x: 2, y: 0, z: 0, c: cBody });
                v.push({ x: 2, y: 0.2, z: 0, c: col, g: true });
            } else if (type === 1) {
                for (let z = 2; z > -2; z--) v.push({ x: 2, y: 0, z: z, c: cBody });
                v.push({ x: 2, y: -1, z: 2, c: cGrip }, { x: 2, y: -1, z: 0, c: cGrip });
                v.push({ x: 2, y: 0.5, z: 0, c: col, g: true });
            } else if (type === 2) {
                v.push({ x: 2, y: -1, z: 2, c: cGrip });
                for (let z = 2; z > -1; z--) { v.push({ x: 1.8, y: 0, z: z, c: cBody }); v.push({ x: 2.2, y: 0, z: z, c: cBody }); }
                v.push({ x: 2, y: 0.2, z: -1, c: col, g: true });
            } else {
                v.push({ x: 2, y: -1, z: 3, c: cGrip });
                for (let z = 3; z > -6; z--) v.push({ x: 2, y: 0, z: z, c: cBody });
                v.push({ x: 1.5, y: 0, z: -2, c: 0x333 }, { x: 2.5, y: 0, z: -2, c: 0x333 });
                v.push({ x: 2, y: 0, z: -5, c: col, g: true }, { x: 2, y: 0, z: -2, c: col, g: true });
            }
            return v;
        }

        function createHandModel() {
            player.handGroup = new THREE.Group();
            camera.add(player.handGroup);
            scene.add(camera);
            updateWeaponVisuals();
        }

        function updateWeaponVisuals() {
            while (player.handGroup.children.length > 0) player.handGroup.remove(player.handGroup.children[0]);
            const w = WEAPONS[currentWepIdx];
            const voxels = getWeaponVoxels(currentWepIdx);
            const mesh = createVoxelGroup(voxels, 0.1);
            mesh.position.set(0.1, -0.4, -0.6);
            player.handGroup.add(mesh);
            player.muzzle = new THREE.PointLight(w.col, 0, 10);
            player.muzzle.position.set(0.3, -0.1, -1.0);
            player.handGroup.add(player.muzzle);
            document.getElementById('weapon-name').innerText = w.name;
            document.getElementById('weapon-name').style.color = '#' + w.col.toString(16).padStart(6, '0');
            document.getElementById('weapon-card').style.borderLeftColor = '#' + w.col.toString(16).padStart(6, '0');
            const next = WEAPONS[currentWepIdx + 1];
            if (next) { document.getElementById('progress-text').innerText = `NEXT: ${next.name} (${next.req} KILLS)`; }
            else { document.getElementById('progress-text').innerText = "MAX LEVEL"; document.getElementById('prog-bar-fill').style.width = '100%'; }
        }

        // --- POOL ---
        function getObj(type, builder) { return pool[type].length > 0 ? pool[type].pop() : builder(); }
        function returnObj(type, obj) { obj.visible = false; pool[type].push(obj); }

        // --- SPAWNING & DIFFICULTY ---
        function increaseDifficulty() {
            GAME_PARAMS.maxEnemies += 3;
            GAME_PARAMS.enemySpeedMult += 0.1;
            GAME_PARAMS.enemyHpMult += 0.2;

            const t = document.getElementById('difficulty-toast');
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }

        function spawnEnemy() {
            if (enemies.length >= GAME_PARAMS.maxEnemies) return;

            const isFly = Math.random() > 0.6; // 40% Flying Drones

            const e = getObj('enemies', () => {
                const g = new THREE.Group();
                const scale = 0.25;
                // Voxel builder
                return g; // We build geometry dynamically below
            });

            // Clear previous geometry if reused (simple approach)
            while (e.children.length > 0) e.remove(e.children[0]);

            let voxels = [];

            if (isFly) {
                // Drone Model
                voxels.push({ x: 0, y: 0, z: 0, c: 0x444444 }, { x: 0, y: 0, z: 1, c: 0x222222 }, { x: 0, y: 0, z: -1, c: 0x222222 }); // Core
                voxels.push({ x: 1, y: 0.5, z: 0, c: 0x111111 }, { x: -1, y: 0.5, z: 0, c: 0x111111 }); // Wings
                voxels.push({ x: 0, y: 0, z: 1.5, c: 0xff0040, g: true }); // Eye
            } else {
                // Walker Model
                voxels.push({ x: 0, y: 2, z: 0, c: 0x333333 }, { x: 0, y: 3, z: 0, c: 0x333333 }); // Body
                voxels.push({ x: 0, y: 3, z: 0.5, c: 0xff0040, g: true }); // Eye
                voxels.push({ x: 1, y: 1, z: 0, c: 0x222222 }, { x: -1, y: 1, z: 0, c: 0x222222 }); // Legs
            }

            const mesh = createVoxelGroup(voxels, 0.3);
            e.add(mesh);

            e.visible = true;
            const ang = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 20;

            // Flying units spawn higher
            const spawnY = isFly ? 10 + Math.random() * 10 : 0;
            e.position.set(camera.position.x + Math.sin(ang) * dist, spawnY, camera.position.z + Math.cos(ang) * dist);

            const hp = (40 + (kills * 1.5)) * (isFly ? 0.7 : 1.2) * GAME_PARAMS.enemyHpMult;
            const speed = (7 + (kills * 0.05)) * (isFly ? 1.5 : 1.0) * GAME_PARAMS.enemySpeedMult;
            const canShoot = Math.random() > 0.4;

            scene.add(e);
            enemies.push({ mesh: e, hp, speed, canShoot, lastFire: 0, isFly, id: Math.random() });
        }

        function spawnProjectile(pos, dir, isEnemy, col) {
            const b = getObj('bullets', () => {
                const g = new THREE.Group();
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                const l = new THREE.PointLight(0xffffff, 0.5, 4);
                g.add(m); g.add(l); return g;
            });
            b.visible = true; b.position.copy(pos);
            b.children[0].material.color.setHex(col); b.children[1].color.setHex(col);
            b.lookAt(pos.clone().add(dir));
            scene.add(b);
            bullets.push({
                mesh: b, dir, life: 2.0,
                spd: isEnemy ? 30 : WEAPONS[currentWepIdx].spd,
                dmg: isEnemy ? 10 : WEAPONS[currentWepIdx].dmg,
                isEnemy
            });
        }

        function fire() {
            const now = performance.now();
            const w = WEAPONS[currentWepIdx];
            if (now - player.lastShot < w.rate * 1000) return;
            player.lastShot = now;

            SoundGen.playShoot();

            player.recoil += 0.2;
            player.muzzle.intensity = 5; setTimeout(() => player.muzzle.intensity = 0, 50);

            const ret = document.getElementById('ret-ring');
            ret.style.width = '50px'; ret.style.height = '50px';
            setTimeout(() => { ret.style.width = '30px'; ret.style.height = '30px' }, 100);

            const count = w.type === 'spread' ? w.count : 1;
            for (let i = 0; i < count; i++) {
                const pos = new THREE.Vector3(); player.muzzle.getWorldPosition(pos);
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                if (w.type === 'spread') {
                    dir.x += (Math.random() - 0.5) * 0.2; dir.y += (Math.random() - 0.5) * 0.2; dir.z += (Math.random() - 0.5) * 0.2; dir.normalize();
                }
                spawnProjectile(pos, dir, false, w.col);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isPlaying) { renderer.render(scene, camera); return; }

            const dt = Math.min(0.05, (performance.now() - lastTime) / 1000);
            lastTime = performance.now();

            // Move
            const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            const move = new THREE.Vector3().addScaledVector(fwd, input.y).addScaledVector(rgt, input.x).normalize().multiplyScalar(CONFIG.speed);
            player.vel.x = THREE.MathUtils.damp(player.vel.x, move.x, 8, dt);
            player.vel.z = THREE.MathUtils.damp(player.vel.z, move.z, 8, dt);
            player.vel.y -= CONFIG.gravity * dt;

            if (camera.position.y <= 3) { camera.position.y = 3; player.vel.y = Math.max(0, player.vel.y); if (input.jump) player.vel.y = CONFIG.jump; }

            const nextPos = camera.position.clone().addScaledVector(player.vel, dt);
            let collide = false;
            const k = `${Math.floor(nextPos.x / CONFIG.chunkSize)},${Math.floor(nextPos.z / CONFIG.chunkSize)}`;
            if (mapChunks.has(k)) {
                mapChunks.get(k).children.forEach(o => { if (o.userData.box && o.userData.box.containsPoint(nextPos)) collide = true; });
            }
            if (!collide) camera.position.copy(nextPos);

            const camTgt = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            camera.lookAt(camera.position.clone().add(camTgt));

            // Hand
            if (player.handGroup) {
                const s = Math.sin(lastTime * 0.005) * 0.02 * (input.x || input.y ? 3 : 1);
                player.recoil = THREE.MathUtils.damp(player.recoil, 0, 8, dt);
                player.handGroup.position.set(0.2 + s, -0.3 + Math.abs(s), -0.5 + player.recoil);
                player.handGroup.rotation.x = player.recoil * 0.5;
            }

            updateWorld();
            if (input.fire) fire();

            // Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.life -= dt;
                b.mesh.position.addScaledVector(b.dir, b.spd * dt);
                let hit = false;

                if (b.isEnemy) {
                    const bodyPos = camera.position.clone();
                    bodyPos.y -= 1.0;
                    if (Math.abs(b.mesh.position.y - bodyPos.y) < 1.5 && b.mesh.position.distanceTo(bodyPos) < 1.0) {
                        hit = true; player.hp -= 15;
                        SoundGen.playHit();
                        document.getElementById('hp-bar-fill').style.width = player.hp + '%';
                        document.getElementById('dmg-overlay').style.opacity = 0.5; setTimeout(() => document.getElementById('dmg-overlay').style.opacity = 0, 100);
                        if (player.hp <= 0) gameOver();
                    }
                } else {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (b.mesh.position.distanceTo(e.mesh.position) < 2.0) { // Hitbox size
                            hit = true; e.hp -= b.dmg;
                            spawnText(e.mesh.position, Math.floor(b.dmg));
                            if (e.hp <= 0) killEnemy(j, e.mesh.position);
                            break;
                        }
                    }
                }

                if (b.mesh.position.y < 0) hit = true;
                if (hit || b.life <= 0) { scene.remove(b.mesh); returnObj('bullets', b.mesh); bullets.splice(i, 1); }
            }

            // Enemies
            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                const dist = e.mesh.position.distanceTo(camera.position);

                // Movement
                if (dist > 5) {
                    const dir = new THREE.Vector3().subVectors(camera.position, e.mesh.position);
                    dir.y = 0; // Flatten movement vector
                    dir.normalize();
                    e.mesh.position.addScaledVector(dir, e.speed * dt);
                    e.mesh.lookAt(new THREE.Vector3(camera.position.x, e.mesh.position.y, camera.position.z));
                }

                // Height Logic
                if (e.isFly) {
                    // Hover logic
                    e.mesh.position.y = 8 + Math.sin(lastTime * 0.002 + e.id * 10) * 2;
                } else {
                    // Ground logic
                    e.mesh.position.y = 0;
                }

                // Shooting
                if (e.canShoot && dist < 40 && (lastTime - e.lastFire > 2000 / GAME_PARAMS.enemySpeedMult)) {
                    e.lastFire = lastTime;
                    const target = camera.position.clone();
                    target.y -= 1.0; // Aim at chest
                    const dir = new THREE.Vector3().subVectors(target, e.mesh.position).normalize();
                    // Offset origin slightly so bullet doesn't hit self
                    const origin = e.mesh.position.clone().add(dir.multiplyScalar(2));
                    spawnProjectile(origin, dir, true, 0xff0040);
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= dt;
                p.mesh.position.addScaledVector(p.vel, dt);
                p.vel.y -= CONFIG.gravity * dt;
                if (p.mesh.position.y < 0) { p.mesh.position.y = 0; p.vel.y *= -0.5; }
                if (p.life <= 0) { scene.remove(p.mesh); returnObj('particles', p.mesh); particles.splice(i, 1); }
            }

            for (let i = texts.length - 1; i >= 0; i--) {
                const t = texts[i]; t.life -= dt;
                if (t.life <= 0) { t.el.remove(); texts.splice(i, 1); continue; }
                const v = t.pos.clone().project(camera);
                const x = (v.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
                t.el.style.left = x + 'px'; t.el.style.top = y + 'px';
            }

            renderer.render(scene, camera);
        }

        function updateWorld() {
            const cx = Math.floor(camera.position.x / CONFIG.chunkSize);
            const cz = Math.floor(camera.position.z / CONFIG.chunkSize);
            const key = `${cx},${cz}`;
            if (!mapChunks.has(key)) {
                const g = new THREE.Group();
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize), new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.8 }));
                floor.rotation.x = -Math.PI / 2; floor.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize);
                g.add(floor);
                const grid = new THREE.GridHelper(CONFIG.chunkSize, 10, 0x444444, 0x222222);
                grid.position.set(cx * CONFIG.chunkSize, 0.05, cz * CONFIG.chunkSize); g.add(grid);

                const seed = Math.abs(Math.sin(cx * 12.98 + cz * 78.23) * 43758.54);
                const count = Math.floor((seed - Math.floor(seed)) * 4) + 2;
                for (let i = 0; i < count; i++) {
                    const h = 5 + Math.random() * 35;
                    const w = 5 + Math.random() * 5;
                    const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                    const ox = (Math.random() - 0.5) * (CONFIG.chunkSize - 10);
                    const oz = (Math.random() - 0.5) * (CONFIG.chunkSize - 10);
                    const pos = new THREE.Vector3(cx * CONFIG.chunkSize + ox, h / 2, cz * CONFIG.chunkSize + oz);
                    b.position.copy(pos);
                    b.userData.box = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(w, h, w));

                    // Windows
                    if (Math.random() > 0.5) {
                        const win = new THREE.Mesh(new THREE.BoxGeometry(w + 0.1, 1, w + 0.1), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                        win.position.y = (Math.random() - 0.5) * h * 0.8;
                        b.add(win);
                    }
                    g.add(b);
                }
                scene.add(g); mapChunks.set(key, g);
            }
        }

        function killEnemy(idx, pos) {
            const e = enemies[idx];
            SoundGen.playExplosion();
            scene.remove(e.mesh); returnObj('enemies', e.mesh);
            enemies.splice(idx, 1);
            for (let i = 0; i < 10; i++) {
                const p = getObj('particles', () => new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0000 })));
                p.visible = true; p.position.copy(pos);
                const vel = new THREE.Vector3(Math.random() - 0.5, Math.random(), Math.random() - 0.5).multiplyScalar(15);
                scene.add(p); particles.push({ mesh: p, vel, life: 1.0 });
            }
            kills++;
            document.getElementById('kill-disp').innerText = kills;

            if (kills > 0 && kills % 20 === 0) {
                increaseDifficulty();
            }
            checkUpgrade();
        }

        function checkUpgrade() {
            const next = WEAPONS[currentWepIdx + 1];
            if (next) {
                const prevReq = WEAPONS[currentWepIdx].req;
                const pct = ((kills - prevReq) / (next.req - prevReq)) * 100;
                document.getElementById('prog-bar-fill').style.width = Math.min(100, pct) + '%';
                if (kills >= next.req) {
                    currentWepIdx++; updateWeaponVisuals();
                    spawnText(camera.position.clone().add(new THREE.Vector3(0, 0, -5)), "WEAPON UPGRADED", true);
                }
            }
        }

        function spawnText(pos, msg, isCrit) {
            const el = document.createElement('div'); el.className = 'float-txt'; el.innerText = msg;
            if (isCrit) el.style.color = '#00ff00';
            document.body.appendChild(el); texts.push({ el, pos: pos.clone(), life: 0.8 });
        }

        function gameOver() {
            isPlaying = false; document.exitPointerLock();
            SoundGen.playDeath();
            document.getElementById('final-kills').innerText = kills;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function setupInput() {
            document.onkeydown = e => { if (e.code == 'KeyW') input.y = 1; if (e.code == 'KeyS') input.y = -1; if (e.code == 'KeyA') input.x = -1; if (e.code == 'KeyD') input.x = 1; if (e.code == 'Space') input.jump = true; };
            document.onkeyup = e => { if (e.code == 'KeyW' || e.code == 'KeyS') input.y = 0; if (e.code == 'KeyA' || e.code == 'KeyD') input.x = 0; if (e.code == 'Space') input.jump = false; };
            document.onmousemove = e => { if (!isMobile && document.pointerLockElement) { yaw -= e.movementX * CONFIG.sens; pitch = Math.max(-1.5, Math.min(1.5, pitch - e.movementY * CONFIG.sens)); } };
            document.onmousedown = () => { if (isPlaying) input.fire = true; }; document.onmouseup = () => { input.fire = false; };

            if (isMobile) {
                const s = document.getElementById('stick-base'), k = document.getElementById('stick-nub'); let sx = 0, sy = 0;
                s.ontouchstart = e => { sx = e.touches[0].clientX; sy = e.touches[0].clientY; };
                s.ontouchmove = e => { e.preventDefault(); const dx = e.touches[0].clientX - sx, dy = e.touches[0].clientY - sy; k.style.transform = `translate(calc(-50% + ${Math.min(40, Math.max(-40, dx))}px),calc(-50% + ${Math.min(40, Math.max(-40, dy))}px))`; input.x = Math.min(1, Math.max(-1, dx / 40)); input.y = -Math.min(1, Math.max(-1, dy / 40)); };
                s.ontouchend = () => { k.style.transform = 'translate(-50%,-50%)'; input.x = 0; input.y = 0; };
                document.getElementById('btn-jump').ontouchstart = e => { e.preventDefault(); input.jump = true; }; document.getElementById('btn-jump').ontouchend = () => { input.jump = false; };
                document.getElementById('btn-fire').ontouchstart = e => { e.preventDefault(); input.fire = true; }; document.getElementById('btn-fire').ontouchend = () => { input.fire = false; };
                let lx = 0, ly = 0;
                document.ontouchstart = e => { for (let i = 0; i < e.touches.length; i++)if (e.touches[i].clientX > window.innerWidth / 2) { lx = e.touches[i].clientX; ly = e.touches[i].clientY; } };
                document.ontouchmove = e => { for (let i = 0; i < e.touches.length; i++)if (e.touches[i].clientX > window.innerWidth / 2) { yaw -= (e.touches[i].clientX - lx) * 0.005; pitch = Math.max(-1.5, Math.min(1.5, pitch - (e.touches[i].clientY - ly) * 0.005)); lx = e.touches[i].clientX; ly = e.touches[i].clientY; } };
            }

            document.getElementById('start-btn').onclick = () => {
                SoundGen.init();
                document.getElementById('start-screen').classList.add('hidden');
                if (!isMobile) document.body.requestPointerLock();
                isPlaying = true;
                setInterval(spawnEnemy, 1500);
            };
        }

        window.onload = init;
        window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>

</html>